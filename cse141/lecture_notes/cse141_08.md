# CSE141 08: Branch Hazards

## Branch Hazards
- Branch dependences can result in branch hazards (when 
they are too close to be handled correctly in the pipeline).

## Dealing With Branch Hazards
- Hardware
  - stall until you know which direction
  - reduce hazard through earlier computation of branch direction
  - guess which direction
    - assume not taken (easiest)
    - more educated guess based on history (requires that you know it is a 
branch before it is even decoded!)
- Hardware/Software/ISA
  - nops, or instructions that get executed either way (delayed branch).

## Stalling for Branch Hazards
- Seems wasteful, particularly when the branch isn’t taken.
- Makes all branches cost 4 cycles.
- Also, requires you know that it’s a branch before you 
decode it (several of our solutions have this problem)

### Assume Branch Not Taken
- Performance depends on percentage of time you guess 
right.
- Flushing an instruction means to prevent it from changing 
any permanent state (registers, memory, PC).
    - sounds a lot like a bubble...
    - But notice that we need to be able to insert those bubbles later in 
the pipeline

### Branch Hazards – Predicting Taken?
Requiredinformation to predict Taken:
1. Whether an instruction is a branch (before decode)
2. The target of the branch
3. The outcome of the branch condition

## Branch Target Buffer
- Keeps track of the PCs of recently seen branches and their 
targets.
- Consult during Fetch (in parallel with Instruction Memory 
read) to determine:
    -  Is this a branch?
    - If so, what is the target